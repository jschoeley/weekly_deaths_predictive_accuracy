# Weekly mortality/deaths predictive accuracy
# Jonas Schöley

# Init ------------------------------------------------------------

library(tidyverse)
library(mgcv)

cnst <- list(
  country = 'DNK',
  week_season_year_starts = 27
)

dat <- list()
fig <- list()
tab <- list()

# Functions -------------------------------------------------------

#' Convert Week of Year to Date
#'
#' @param year Year integer.
#' @param week Week of year integer (1 to 53).
#' @param weekday Weekday integer (1, Monday to 7, Sunday).
#' @param offset Integer offset added to `week` before date calculation.
#'
#' @return A date object.
#' 
#' @source https://en.wikipedia.org/wiki/ISO_8601
#'
#' @author Jonas Schöley
#'
#' @examples
#' # the first Week of 2020 actually starts Monday, December 30th 2019
#' ISOWeekDate2Date(2020, 1, 1)
ISOWeekDate2Date <- function (year, week, weekday = 1, offset = 0) {
  require(ISOweek)
  isoweek_string <-
    paste0(
      year, '-W',
      formatC(
        week+offset,
        flag = '0',
        format = 'd',
        digits = 1
      ),
      '-', weekday
    )
  ISOweek2date(isoweek_string)
}

#' Calculate Weeks Since Some Origin Date
#'
#' @param date Date string.
#' @param origin_date Date string.
#' @param week_format Either 'integer' for completed weeks or
#' 'fractional' for completed fractional weeks.
#'
#' @return Time difference in weeks.
#' 
#' @author Jonas Schöley
#'
#' @examples
#' # My age in completed weeks
#' WeeksSinceOrigin('2020-07-07', '1987-07-03')
WeeksSinceOrigin <-
  function (date, origin_date, week_format = 'integer') {
    require(ISOweek)
    fractional_weeks_since_origin <-
      as.double(difftime(
        as.Date(date),
        as.Date(origin_date),
        units = 'weeks'
      ))
    switch(
      week_format,
      fractional = fractional_weeks_since_origin,
      integer = as.integer(fractional_weeks_since_origin)
    )
  }

SeasonYearSequence <- function (from, to) {
  years <- from:to
  paste0(head(years, -1), '/', years[-1])
}

AbsolutePercentageError <- function (observed, predicted) {
  ((observed - predicted) / observed)*100
}

# This model and estimates the average mortality rate over
# some years within each week and stratum. The associated
# predict() method multiplies this average mortality with
# given exposures to derive death counts.

AverageMortalityModel <-
  function (df, week, deaths, exposures, ...) {
    require(dplyr)
    .strata = enquos(...); .week = enquo(week);
    .deaths = enquo(deaths); .exposures = enquo(exposures)
    
    avg_mx <-
      df %>%
      group_by(!!!.strata, !!.week) %>%
      summarise(
        avg_mortality = mean(!!.deaths/!!.exposures),
        .groups = 'drop'
      )
    
    structure(list(avg = avg_mx), class = 'avgmx')
    
  }

predict.avgmx <- function (object, newdata, ...) {
  require(dplyr)
  left_join(newdata, object$avg) %>%
    pull(avg_mortality)
}

# Load data -------------------------------------------------------

dat$raw <-
  readr::read_csv(
    "data/stmf-2.csv",
    col_types = "ciicddddddddddddlll",
    skip = 2, col_names = TRUE
  )

# Prepare data ----------------------------------------------------

dat$ts <-
  dat$raw %>%
  filter(
    CountryCode == cnst$country,
    Sex != 'b'
  ) %>%
  select(
    year = Year, week = Week, sex = Sex, D0_14:D85p, R0_14:R85p,
  ) %>%
  pivot_longer(
    cols = D0_14:R85p,
    names_sep = 1,
    names_to = c('statistic', 'age_group'),
    values_to = 'value'
  ) %>%
  pivot_wider(
    names_from = statistic,
    values_from = value
  ) %>%
  # discard lowest age group as it carries almost no information,
  # yet clutters the display of results
  filter(age_group != '0_14') %>%
  rename(observed_deaths = D, observed_mortality = R) %>%
  mutate(
    # use same weekly exposure as used by HMD
    exposure =
      observed_deaths / observed_mortality,
    date =
      ISOWeekDate2Date(year, week, 1),
    start_of_season_year =
      ISOWeekDate2Date(
        ifelse(week<=cnst$week_season_year_starts, year-1, year),
        cnst$week_season_year_starts, 1
      ),
    season_year =
      paste0(lubridate::year(start_of_season_year),'/',
             lubridate::year(start_of_season_year)+1),
    season_year_int =
      as.integer(substr(season_year,1,4)),
    weeks_into_season_year =
      difftime(date, start_of_season_year, units = 'weeks') %>%
      floor() %>% as.integer()
  )

# Create training/test sets ---------------------------------------

dat$ts %>%
  mutate(m = observed_deaths/exposure) %>%
  ggplot() +
  geom_point(aes(x = date, y = m)) +
  scale_x_date(date_breaks = '3 months', date_labels = '%b') +
  facet_wrap(~season_year, scales = 'free_x')

dat$tt <-
  # set up K-fold cross-validation
  #SWE map2(2000+0:12, 2004+0:12, SeasonYearSequence) %>%
  #ENW map2(2010+0:5, 2014+0:5, SeasonYearSequence) %>%
  map2(2006+0:8, 2011+0:8, SeasonYearSequence) %>%
  map(~filter(dat$ts, season_year %in% .x)) %>%
  map(~mutate(
    .x, training = ifelse(
      season_year_int == max(season_year_int) |
        (year == max(season_year_int) & week >= 10),
      'test', 'training')
  )) %>%
  bind_rows(.id = 'cv_id') %>%
  mutate(cv_id = as.integer(cv_id)) %>%
  expand_grid(
    model = c(
      'average',
      'glm.serfling',
      'gam.pois',
      'gam.nb',
      'gam.nb.re',
      'gam.nb.wt'
    )
  ) %>%
  nest(data = c(-model, -cv_id))

# Model time series -----------------------------------------------

dat$mod <-
  dat$tt %>%
  group_by(model, cv_id) %>%
  group_modify(~{
    
    cat(unlist(.y), sep = '\n')
    
    ### PREPARE INPUT DATA
    
    # season-years in training data
    # I use this later to check if prediction
    # outside the range of season_years in training
    # data will be required
    season_years_in_training <-
      .x$data[[1]] %>%
      filter(training == 'training') %>%
      pull(season_year) %>% unique()
    
    # prepare for model
    model_data <-
      .x$data[[1]] %>%
      mutate(
        weeks_since_origin =
          WeeksSinceOrigin(date, min(date)),
        observed_mortality =
          observed_deaths / exposure,
        new_year =
          ifelse(week == 52, 1, 0),
        sex_age_interaction =
          interaction(sex, age_group),
        include_re =
          ifelse(season_year %in% season_years_in_training, 1, 0),
        season_year_sex_age_interaction =
          interaction(season_year, sex, age_group)
      )
    
    training_data <-
      model_data %>%
      filter(training == 'training') %>%
      mutate(weight = exp(weeks_since_origin/max(weeks_since_origin)*1.5))
    
    ### TRAIN MODELS
    
    if (.y$model == 'average') {
      
      # calculate average weekly mortality rate over training data
      model <-
        AverageMortalityModel(
          training_data,
          weeks_into_season_year,
          observed_deaths,
          exposure,
          sex, age_group
        )
      
    }
    
    if (.y$model == 'glm.serfling') {
      
      model <-
        glm(
          observed_deaths ~
            # log linear long term trend
            weeks_since_origin*sex*age_group +
            # seasonality
            # full year period
            sin(2*pi*weeks_into_season_year/(365.25/7))*sex*age_group +
            cos(2*pi*weeks_into_season_year/(365.25/7))*sex*age_group +
            # half year period
            sin(2*pi*weeks_into_season_year/(365.25/2/7))*sex*age_group +
            cos(2*pi*weeks_into_season_year/(365.25/2/7))*sex*age_group +
            # adjustment for new years eve
            new_year*sex*age_group +
            # exposures
            offset(log(exposure)),
          data = training_data,
          family = poisson(link = 'log')
        )
      
    }
    
    if (.y$model == 'gam.pois') {
      
      model <-
        gam(
          observed_deaths ~
            1 + sex + age_group +
            # log linear long term trend
            weeks_since_origin*sex_age_interaction +
            # penalized cyclic spline for seasonality
            s(weeks_into_season_year, bs = 'cp', k = 52, by = sex_age_interaction) +
            # adjustment for new years eve
            new_year*sex_age_interaction +
            # exposures
            offset(log(exposure)),
          data = training_data,
          family = quasipoisson(link = 'log'),
          method = 'REML'
        )

    }

    if (.y$model == 'gam.nb') {
      
      model <-
        gam(
          observed_deaths ~
            1 + sex + age_group +
            # log linear long term trend
            weeks_since_origin*sex_age_interaction +
            # penalized cyclic spline for seasonality
            s(weeks_into_season_year, bs = 'cp', k = 52, by = sex_age_interaction) +
            # adjustment for new years eve
            new_year*sex_age_interaction +
            # exposures
            offset(log(exposure)),
          data = training_data,
          family = nb(link = 'log'),
          method = 'REML'
        )
      
    }

    if (.y$model == 'gam.nb.wt') {
      
      model <-
        gam(
          observed_deaths ~
            1 + sex + age_group +
            # log linear long term trend
            weeks_since_origin*sex_age_interaction +
            # penalized cyclic spline for seasonality
            s(weeks_into_season_year, bs = 'cp', k = 52, by = sex_age_interaction) +
            # adjustment for new years eve
            new_year*sex_age_interaction +
            # exposures
            offset(log(exposure)),
          data = training_data,
          family = nb(link = 'log'),
          method = 'REML',
          weights = weight
        )
      
    }
    
    if (.y$model == 'gam.nb.re') {
      
      model <-
        gam(
          observed_deaths ~
            1 + sex + age_group +
            # log linear long term trend
            weeks_since_origin*sex_age_interaction +
            # penalized cyclic spline for seasonality
            s(weeks_into_season_year, bs = 'cp', k = 52, by = sex_age_interaction) +
            # adjustment for new years eve
            new_year*sex_age_interaction +
            # season year random effect adjustment
            s(season_year_sex_age_interaction, bs = 're') +
            # exposures
            offset(log(exposure)),
          data = training_data,
          family = nb(link = 'log'),
          method = 'REML'
        )
      
    }
    
        
    ### PREDICT FROM MODEL
    
    cat('foo')
    
    predictions <-
      model_data %>%
      group_by(include_re) %>%
      group_modify(~{
        newdata <- mutate(.x, exposure = 1)
        # this is to allow predictions with novel levels in
        # random effects variables. for the novel levels the
        # random effect is then set to 0.
        exclude = NULL
        if (.y == 0) {
          newdata$season_year_sex_age_interaction <- NULL
          exclude <- 's(season_year_sex_age_interaction)'
        }
        # predict mortality rates
        mutate(
          .x,
          predicted_mortality =
            predict(
              model,
              newdata = newdata,
              type = 'response',
              # for prediction with random effects
              exclude = exclude,
              newdata.guaranteed = TRUE
            ))
      }) %>%
      ungroup() %>%
      mutate(
        predicted_deaths =
          predicted_mortality * exposure,
        residual_mortality_ape =
          AbsolutePercentageError(observed_mortality, predicted_mortality),
        residual_deaths_ape =
          AbsolutePercentageError(observed_deaths, predicted_deaths),
        residual_deaths_e =
          observed_deaths - predicted_deaths
      )
    
    result <-
      tibble(
        training_data = list(training_data),
        predictions = list(predictions),
        fitted_model = list(model)
      )
    
    return(result)
    
  }) %>%
  ungroup()

# Predictive accuracy -----------------------------------------------------

dat$resid <-
  dat$mod %>%
  unnest(predictions) %>%
  group_by(model, training, age_group) %>%
  summarise(
    mae = median(abs(residual_deaths_e), na.rm = TRUE),
    q25 = quantile(residual_mortality_ape, 0.25, na.rm = TRUE),
    q75 = quantile(residual_mortality_ape, 0.75, na.rm = TRUE)
  ) %>%
  ungroup()

dat$resid %>%
  pivot_wider(names_from = training, values_from = mae, id_cols = c(model, age_group)) %>%
  mutate(model = fct_reorder(model, test, .desc = TRUE, .fun = mean)) %>%
  ggplot() +
  geom_point(aes(x = model, y = training)) +
  geom_segment(aes(x = model, xend = model, y = training, yend = test),
               arrow = arrow(angle = 10, type = 'closed')) +
  geom_text(aes(x = model, y = test,
                label = paste0(formatC(test, digits = 2, format = 'f'))),
            nudge_x = 0.2) +
  coord_flip() +
  facet_wrap(~age_group, scales = 'free_x')

scaler <- 200
dat$mod %>%
  unnest(predictions) %>%
  group_by(model, cv_id, date, training) %>%
  summarise(
    observed_mortality = sum(observed_deaths)/sum(exposure),
    predicted_mortality = sum(predicted_deaths)/sum(exposure)
  ) %>%
  ggplot(aes(x = date)) +
  geom_line(aes(group = cv_id, color = training, y = cv_id + scaler*observed_mortality)) +
  geom_line(aes(y = scaler*observed_mortality)) +
  geom_line(aes(y = cv_id + scaler*predicted_mortality, group = cv_id)) +
  facet_wrap(~model, nrow = 2)

dat$mod %>%
  unnest(predictions) %>%
  ggplot(aes(x = week, y = residual_mortality_ape)) +
  geom_point(
    aes(color = training)
  ) +
  geom_smooth(
    aes(group = training, lty = training),
    se = FALSE, color = 'black'
  ) +
  geom_hline(yintercept = 0) +
  facet_wrap(~model, nrow = 2)

dat$mod %>%
  unnest(predictions) %>%
  filter(training == 'test') %>%
  ggplot() +
  geom_density(
    aes(
      x = residual_deaths_e,
      color = model
    )
  ) +
  scale_x_continuous() +
  geom_vline(xintercept = 0) +
  facet_wrap(~age_group)
